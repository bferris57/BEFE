#!/usr/bin/env python3

import                    time
import                    curses
import                    random
from   curses      import wrapper
import                    sys
from   funcs       import dtNow
from   funcs       import dtToNonce
from   funcs       import red,blue,green
from   errors             import *

lines = '∙√─│┌┐└┘├┬┴┼═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬▲►▼◄◊☺☻'

ld_tl   = '┌'
ld_tr   = '┐'
ld_bl   = '└'
ld_br   = '┘'
ld_hor  = '─'
ld_vert = '│'
ld_rarr = '►'
ld_larr = '◄'
ld_uarr = '▲'
ld_darr = '▼'
ld_0    = '\u24ea'
ld_1    = '\u2460'
ld_2    = '\u2461'
ld_3    = '\u2462'
ld_4    = '\u2463'
ld_5    = '\u2464'
ld_6    = '\u2465'
ld_7    = '\u2466'
ld_8    = '\u2467'
ld_9    = '\u2468'
ld_10   = '\u2469'
ld_11   = '\u246a'
ld_12   = '\u246b'
ld_13   = '\u246c'

ld_numbers = ld_0+ld_1+ld_2+ld_3+ld_4+ld_5+ld_6+ld_7+ld_8+ld_9+ld_10
ld_club    = ld_tl+ld_hor+'\u2660'+ld_hor+ld_tr
ld_suit    = '\u2660\u2661\u2662\u2663'
#ld_deck    = ld_0+'A'+ld_2+ld_3+ld_4+ld_5+ld_6+ld_7+ld_8+ld_9+ld_10+'JQK'
ld_deck    = '0A234567890JQK'

maxx = None
maxy = None

topnum = '┌─x─┐'
top    = '┌───┐'
topvis = top #ld_club
mid    = '│   │'
midnum = '│ x │'
bot    = '└───┘'

def shuffle(arr):

  if type(arr) != type([]):
    raise Error('shuffle: Expected list')

  deck = []
  for x in arr: deck.append(x)

  ret = []

  while deck:
    thisone = random.randint(0,len(deck)-1)
    ret.append(deck[thisone])
    del deck[thisone]

  return ret

def renderAll(decks,stacks,msg):

  scr.clear()
  # DEBUG...
  scr.addstr(0,0,'stack[0] = %s'%repr(stacks[0]),curses.A_REVERSE)
  # ...DEBUG

  y = 1
  x = 0
  for s in range(0,len(stacks)):
    renderDeck(y,x+s*7,stacks[s])

  scr.refresh()

def renderDeck(y,x,deck,selected=None):

  if not deck:
    return

  selected = None

  for cardno in range(0,len(deck)):
    card = deck[cardno]
    if card <= 0:
      tstr = topvis
    else:
      tstr = ld_deck[card].join(topnum.split('x'))
    if selected == cardno:
      scr.addstr(y+i,x,tstr,curses.A_REVERSE)
    else:
      scr.addstr(y+cardno,x,tstr)
    if cardno == len(deck)-1:
      y = y + len(deck) - 1
      scr.addstr(y  , x, top)
      scr.addstr(y+1, x, mid)
      scr.addstr(y+2, x, ld_deck[card].join(midnum.split('x')))
      scr.addstr(y+3, x, mid)
      scr.addstr(y+4, x, bot)

  scr.refresh()

def dealOne(decks,stack):

  if not decks:
    return
  card = decks[-1][-1]
  stack.append(card)
  del decks[-1][-1]
  if not decks[-1]:
    del decks[-1]
      
def main(screen):

  global scr
  global maxx
  global maxy

  scr = screen

  scr.clear()
  scr.refresh()
  scr.timeout(200)
  curses.curs_set(0)

  maxy, maxx = scr.getmaxyx()

  scr.addstr(maxy-1,0,'Press any \'q\' or \'x\' to exit...')
  scr.refresh()

  # Create randomly shuffled decks...

  deck = [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13]
  decks = []
  for i in range(0,8): # Create original decks...
    thisone = shuffle(deck)
    decks.append(thisone)

  # Deal stacks...
  stacks = ([],[],[],[],[],[],[],[],[],[])
  cardno = 0
  for d in range(0,6):
    while cardno < 54:
      dealOne(decks,stacks[cardno%len(stacks)])
      cardno += 1

  for s in range(0,len(stacks)):
    stack = stacks[s]
    if stack and stack[-1] < 0:
      stack[-1] = -stack[-1]

  renderAll(decks,stacks,"Press \'q\' or \'x\' to exit...")

  #
  # Do it...
  #

  key = ''
  while key not in ('q','Q','x','X'):
    dt = dtToNonce(dtNow()).split('T')[1][:-4]
    scr.addstr(0,maxx-len(dt),dt)
    key = scr.getch()
    if key < 0: continue
    # TEMP...
    scr.addstr(0,0,'Key: 0x'+'%x'%key+'          ',curses.A_REVERSE)
    # ...TEMP
    key = chr(key)

  #scr.clear()
  #scr.refresh()
  #time.sleep(3)

if __name__ == '__main__':

  if 1:

    wrapper(main)

  if 0:

    deck = shuffle([1,2,3,4,5,6,7,8,9,10,11,12,13])
    print('deck = %s'%repr(deck))
      
  if 0:

    try:
      raise(InternalError('Testing InternalError()'))
    except InternalError as e:
      red(str(e))
