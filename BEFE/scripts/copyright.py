#!/usr/bin/env python3
# coding=utf-8

# External modules
import                    os.path
import                    string
import                    sys
import                    shutil
import                    colr
from   utils.funcs import execute
from   utils.funcs import Prefix
from   utils.funcs import red,green

# Default configurables
here = os.path.dirname(os.path.abspath(__file__))
root = os.path.abspath(here+'/..')
BEFE_SrcRoot  = root + '/BEFE-Core'
BEFE_BuildDir = root + '/temp'
#print("DEBUG: BEFE_SrcRoot  = %s"%repr(BEFE_SrcRoot))

#-------------------------------------------------------------------------------
#
# Function: PathSplit
#
# Purpose:  Split an OS file path into constituent parts. Takes both Windows
#           (e.g. "c:\dir\dir...") and Linux/Unix (e.g. "/usr/bin") formats.
#
# Args:     path - String: Path to split
#
# Returns:  List of path parts.
#
# Notes:    Doesn't currently handle Windows network pathc (e.g. '\\mypc\...')
#
#           Leading '/' '\\' etc. will return empty strings in the list.
#

def PathSplit(path):
  if path.find('/') >= 0:
    return path.split('/')
  elif path.find('\\') >= 0:
    return path.split('\\')
  return path

#-------------------------------------------------------------------------------
#
# Function: PathNormalise
#
# Purpose:  Ensure an OS path is Linux/Unix instead of Windows format
#
# Args:     path - String: The path to normalise
#
# Returns:  Normalised path (e.g. "c:\SVN\befe" becomes "c:/SVN/befe"
#

def PathNormalise(thePath):
  if thePath.find('\\') >= 0:
    return string.join(thePath.split('\\'),'/')
  return thePath

#-------------------------------------------------------------------------------
#
# Generator: PathWalker
#
# Purpose:   Walk and visit every entry, deep, in a given OS path
#
# Args:      path - String: The path to walk
#
# Notes:     If the path doesn't exist or isn't a directory, PathWalker doesn't
#            generate anything
#
#            If you send this generator a False, it will skip going deep. This
#            is handy if you want to ignore certain directories. Example...
#
#              walker = PathWalker(path)
#              for path in walker:
#                # Skip if unwanted directory
#                if os.path.isdir(path) and dontWant(path):
#                  walker.send(false)
#                  continue
#                # We want this one...
#                ...
#
#             The paths generated by PathWalker are in normalised form
#             (see PathNormalise above)
#

def PathWalker(path):

  # See if anything to do
  path = PathNormalise(path)
  if type(path) != str or not os.path.isdir(path):
    return

  # Populate initial stack
  stack = PathSplit(path)
  for i in range(0,len(stack)):
    stack[i] = [stack[i]]

  # Until Finished...
  while stack:

    # Get current path
    path = '/'
    for level in stack:
      if path and path[-1] != '/':
        path += '/'
      path += level[0]

    # Give it to the caller...
    if os.path.isdir(path) or os.path.isfile(path):
      wanted = yield path
      if wanted == None:
        wanted = True
    else:
      wanted = False

    # If dir: Go deeper if wanted
    if wanted and os.path.isdir(path):
      contents = os.listdir(path)
      if contents:
        contents.sort()
        stack.append(contents)
        continue

    # Was either a file or an empty directory, get rid of it cascading...
    while stack:
      if not stack[-1]:
        del stack[-1]
        continue
      del stack[-1][0]
      if stack[-1]:
        break;

#-------------------------------------------------------------------------------
#
# Function: fixCopyright - Fix copyright in source
#
# Purpose:  Fix copyright in source files
#

def fixCopyright():

  # Do it...
  walker = PathWalker(BEFE_SrcRoot)
  total = 0
  fixed = 0
  for path in walker:
    wantIt = path.endswith('.h') or path.endswith('.cpp')
    if not wantIt:
      continue
    if not os.path.isfile(path):
      continue

    total += 1

    # Fix it if need be...
    if total%10 == 0:
      print('.',end='')
      sys.stdout.flush()

    lines = open(path,'r').readlines()
    fixedIt = False
    for lineno in range(0,len(lines)):
      line = lines[lineno]
      if not '// Copyright ' in line: continue
      if not '2004'      in line: continue
      pos = line.find('-')
      if pos < 0: continue
      line = line[:pos] + line[pos+5:]
      lines[lineno] = line
      fixedIt = True
      break
    if fixedIt:
      fixed += 1
      open(path,'w').writelines(lines)

  print('')
  print("  Total Files =",total)
  print("  Fixed Files =",fixed)

  return

#-------------------------------------------------------------------------------
#
# Block:   __main__
#
# Purpose:  Python Main
#
# NOTE: ld temp/_obj/*.o -o temp/bin/befe -m elf_i386 -fno-use-cxa-atexit 2>ld.err

if __name__ == "__main__":

  fixCopyright()
