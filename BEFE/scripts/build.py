#!/usr/bin/env python
# coding=utf-8
#===============================================================================
#
# File: build.py
#
# Purpose: Build BEFE executable
#
# Usage:   python build.py [args]
#
# Where:   args - Optional...
#
#===============================================================================

# External modules
#import os
import os.path
import string
import sys
import shutil

# Default configurables
here = os.path.dirname(os.path.abspath(__file__))
root = os.path.abspath(here+'/..')
BEFE_SrcRoot  = root+'/BEFE-Core'
BEFE_BuildDir = root+'/temp'
print("DEBUG: BEFE_SrcRoot  = %s"%repr(BEFE_SrcRoot))
print("       BEFE_BuildDir = %s"%repr(BEFE_BuildDir))

# Handy flags
IsWin32 = sys.platform == 'win32'

#-------------------------------------------------------------------------------
#
# Function: PathSplit
#
# Purpose:  Split an OS file path into constituent parts. Takes both Windows
#           (e.g. "c:\dir\dir...") and Linux/Unix (e.g. "/usr/bin") formats.
#
# Args:     path - String: Path to split
#
# Returns:  List of path parts.
#
# Notes:    Doesn't currently handle Windows network pathc (e.g. '\\mypc\...')
#
#           Leading '/' '\\' etc. will return empty strings in the list.
#

def PathSplit(path):
  if path.find('/') >= 0:
    return path.split('/')
  elif path.find('\\') >= 0:
    return path.split('\\')
  return path

#-------------------------------------------------------------------------------
#
# Function: PathNormalise
#
# Purpose:  Ensure an OS path is Linux/Unix instead of Windows format
#
# Args:     path - String: The path to normalise
#
# Returns:  Normalised path (e.g. "c:\SVN\befe" becomes "c:/SVN/befe"
#

def PathNormalise(thePath):
  if thePath.find('\\') >= 0:
    return string.join(thePath.split('\\'),'/')
  return thePath

#-------------------------------------------------------------------------------
#
# Generator: PathWalker
#
# Purpose:   Walk and visit every entry, deep, in a given OS path
#
# Args:      path - String: The path to walk
#
# Notes:     If the path doesn't exist or isn't a directory, PathWalker doesn't
#            generate anything
#
#            If you send this generator a False, it will skip going deep. This
#            is handy if you want to ignore certain directories. Example...
#
#              walker = PathWalker(path)
#              for path in walker:
#                # Skip if unwanted directory
#                if os.path.isdir(path) and dontWant(path):
#                  walker.send(false)
#                  continue
#                # We want this one...
#                ...
#
#             The paths generated by PathWalker are in normalised form
#             (see PathNormalise above)
#

def PathWalker(path):

  # See if anything to do
  path = PathNormalise(path)
  if type(path) != str or not os.path.isdir(path):
    return

  # Populate initial stack
  stack = PathSplit(path)
  for i in range(0,len(stack)):
    stack[i] = [stack[i]]

  # Until Finished...
  while stack:

    # Get current path
    path = '/'
    for level in stack:
      if path and path[-1] != '/':
        path += '/'
      path += level[0]

    # Give it to the caller...
    if os.path.isdir(path) or os.path.isfile(path):
      wanted = yield path
      if wanted == None:
        wanted = True
    else:
      wanted = False

    # If dir: Go deeper if wanted
    if wanted and os.path.isdir(path):
      contents = os.listdir(path)
      if contents:
        stack.append(contents)
        continue

    # Was either a file or an empty directory, get rid of it cascading...
    while stack:
      if not stack[-1]:
        del stack[-1]
        continue
      del stack[-1][0]
      if stack[-1]:
        break;

#-------------------------------------------------------------------------------
#
# Function: Clean
#
# Purpose:  Clean the build directory
#
# Args:     dir - String: Build directory (None means use BEFE_BuildDir)
#
# Returns:  None
#

def Clean(directory = None):

  if directory == None:
    directory = BEFE_BuildDir

  if not os.path.exists(directory) or not os.path.isdir(directory):
    return

  shutil.rmtree(directory)

#-------------------------------------------------------------------------------
#
# Function: Empty
#
# Purpose:  Create structered but empty build directory
#
# Args:     directory - String: Build directory (None means use BEFE_BuildDir)
#
# Returns:  None
#

def Empty(directory = None):

  # Default parameters
  if directory == None:
    directory = BEFE_BuildDir
  directory = PathNormalise(directory)

  # List of dirs to build
  dirs = ['bin',
          'doc',
          'home',
          'inc',
          'lib',
          'obj',
          'src',
          '_bin',
          '_doc',
          '_inc',
          '_lib',
          '_obj',
          '_src',
         ]

  # Remove it
  Clean(directory)

  # Make them
  if not os.path.exists(directory):
    os.mkdir(directory)
  for sdir in dirs:
    os.makedirs(directory + '/' + sdir)

  return

#-------------------------------------------------------------------------------
#
# Function: CopySource
#
# Purpose:  Copy source to build directory
#
# Notes:    If the destination file already exists (e.g. if the directories
#           haven't been cleaned or emptied), it will only be copied if
#           the destination file is older than the source file.
#

def CopySource():

  # Destinations
  dests = {
            '.c':BEFE_BuildDir+'/_src',
          '.cpp':BEFE_BuildDir+'/_src',
            '.h':BEFE_BuildDir+'/_inc',
          }

  # Do it...
  walker = PathWalker(BEFE_SrcRoot)
  total = 0
  copied = 0
  for path in walker:
    WantIt = True
    if IsWin32:
      dontWant = 'linux'
    else:
      dontWant = 'win32'
    if path.find('/.') >= 0: WantIt = False
    if dontWant in path:    WantIt = False
    if not WantIt:
      continue
    if not os.path.isfile(path):
      continue
    ext = os.path.splitext(path)[1].lower()
    if not ext in dests:
      continue

    total += 1

    # Copy it...
    dest = dests[ext]
    _,fileName = os.path.split(path)
    dest += '/'+fileName
    doit = True
    if os.path.exists(dest) and os.path.isfile(dest) and os.path.getmtime(path) <= os.path.getmtime(dest):
      doit = False
    if doit:
      if os.path.exists(dest):
        os.remove(dest)
      shutil.copy(path,dest)
      shutil.copystat(path,dest)
      copied += 1

  print("  Total Files  =",total)
  print("  Copied Files =",copied)

  return

#-------------------------------------------------------------------------------
#
# Function: ValidateExecutables
#
# Purpose:  Validate that required executables are on the search path
#

#-------------------------------------------------------------------------------
#
# Function: **None**
#
# Purpose:  Python Main
#

if __name__ == "__main__":

  if True:
    print("Cleaning...")
    Clean()
    print("Creating empty build structure...")
    Empty()
  print("Copying files...")
  CopySource()
  print("** Build Finished**")
